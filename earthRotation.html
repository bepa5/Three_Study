<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åœ°çƒè‡ªè½¬ğŸŒ</title>
    <style>
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.122.0/examples/js/controls/OrbitControls.min.js"></script>
</head>

<body>
    <canvas class="webgl"></canvas>
    <script>
        const sizes = {
            width: window.innerWidth,
            height: window.innerHeight

        };
        //åˆå§‹åŒ–æ¸²æŸ“å™¨
        //è·å–å…ƒç´ 
        const canvas = document.querySelector('canvas.webgl')
        //æ¸²æŸ“å™¨å¹¶æ¸²æŸ“canvas
        const renderer = new THREE.WebGLRenderer({ canvas: canvas });
        //è®¾ç½®æ¸²æŸ“å™¨çš„å®½é«˜ï¼Œæ ¹æ®æµè§ˆå™¨å¯è§†çª—å£
        renderer.setSize(sizes.width, sizes.height);
        //è®¾ç½®è®¾å¤‡åƒç´ æ¯”ç‡
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

        //åˆå§‹åŒ–åœºæ™¯
        const scene = new THREE.Scene()
        //è®¾ç½®åœºæ™¯èƒŒæ™¯
        scene.background = new THREE.Color(0x1A1A1A)
        //å¤šé›¾è·¯æ®µ
        scene.fog = new THREE.Fog(0x1A1A1A, 1, 1000)

        //åˆå§‹åŒ–ç›¸æœº
        const camera = new THREE.PerspectiveCamera(40, sizes.width / sizes.height)
        //å°†ç›¸æœºæ·»åŠ åˆ°åœºæ™¯ä¸­
        scene.add(camera)
        //è®¾ç½®ç›¸æœºåœ¨ 3d ç©ºé—´ (x,y,z) åæ ‡ä¸­çš„ä½ç½®
        camera.position.set(20, 100, 450)

        //é¡µé¢ç¼©æ”¾äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', () => {
            sizes.width = window.width;
            sizes.height = window.height;
            //æ›´æ–°æ¸²æŸ“
            renderer.setSize(sizes.width, sizes.height);
            //è®¾ç½®è®¾å¤‡åƒç´ æ¯”ç‡
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
            //æ›´æ–°ç›¸æœº
            camera.aspect = sizes.width / sizes.height;
            camera.updateProjectionMatrix();
        })
        // æ·»åŠ åæ ‡è½´è¾…åŠ©å™¨
        const axesHelper = new THREE.AxesHelper(5);
        scene.add(axesHelper);
        //åˆå§‹åŒ–æ§åˆ¶å™¨
        const controls = new THREE.OrbitControls(camera, renderer.domElement)
        controls.enableDamping = true

        //æ·»åŠ å…‰æº
        const light = new THREE.AmbientLight(0xdeedff, 1.5)
        scene.add(light)

        //åˆ›å»ºæ˜Ÿçƒ
        //ç½‘çŠ¶Lambertææ–™
        const SphereMaterial = new THREE.MeshLambertMaterial({
            color: 0x03c03c,
            wireframe: true
        })
        //åˆ›å»ºæƒ³è¦çš„ç«‹ä½“å›¾å½¢
        const SphereGeometry = new THREE.SphereGeometry(80, 32, 32)
        //ç½‘æ ¼
        const planet = new THREE.Mesh(SphereGeometry, SphereMaterial)
        scene.add(planet)
        // åˆ›å»ºæ˜Ÿçƒè½¨é“ç¯
        const TorusGeometry = new THREE.TorusBufferGeometry(150, 8, 2, 120);
        const TorusMaterial = new THREE.MeshLambertMaterial({
            color: 0x40a9ff,
            wireframe: true
        });
        const ring = new THREE.Mesh(TorusGeometry, TorusMaterial);
        ring.rotation.x = Math.PI / 2;
        ring.rotation.y = -0.1 * (Math.PI / 4);
        scene.add(ring);

        // åˆ›å»ºå«æ˜Ÿ
        const IcoGeometry = new THREE.IcosahedronGeometry(16, 0);
        const IcoMaterial = new THREE.MeshToonMaterial({ color: 0xfffc00 });
        const satellite = new THREE.Mesh(IcoGeometry, IcoMaterial);
        scene.add(satellite);

        // åˆ›å»ºæ˜Ÿæ˜Ÿ
        const stars = new THREE.Group();
        for (let i = 0; i < 500; i++) {
            const geometry = new THREE.IcosahedronGeometry(Math.random() * 2, 0);
            const material = new THREE.MeshToonMaterial({ color: 0xeeeeee });
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.x = (Math.random() - 0.5) * 700;
            mesh.position.y = (Math.random() - 0.5) * 700;
            mesh.position.z = (Math.random() - 0.5) * 700;
            mesh.rotation.x = Math.random() * 2 * Math.PI;
            mesh.rotation.y = Math.random() * 2 * Math.PI;
            mesh.rotation.z = Math.random() * 2 * Math.PI;
            stars.add(mesh);
        }
        scene.add(stars);

        // é¡µé¢ç¼©æ”¾äº‹ä»¶ç›‘å¬
        window.addEventListener('resize', () => {
            sizes.width = window.innerWidth;
            sizes.height = window.innerHeight;
            // æ›´æ–°æ¸²æŸ“
            renderer.setSize(sizes.width, sizes.height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))
            // æ›´æ–°ç›¸æœº
            camera.aspect = sizes.width / sizes.height;
            camera.updateProjectionMatrix();
        });

        let rot = 0;
        // åŠ¨ç”»
        const axis = new THREE.Vector3(0, 0, 1);
        const tick = () => {
            // æ›´æ–°æ¸²æŸ“å™¨
            renderer.render(scene, camera);
            // ç»™ç½‘æ ¼æ¨¡å‹æ·»åŠ ä¸€ä¸ªè½¬åŠ¨åŠ¨ç”»
            rot += Math.random() * 0.8;
            const radian = (rot * Math.PI) / 180;
            // æ˜Ÿçƒä½ç½®åŠ¨ç”»
            planet && (planet.rotation.y += .005);
            // æ˜Ÿçƒè½¨é“ç¯ä½ç½®åŠ¨ç”»
            ring && ring.rotateOnAxis(axis, Math.PI / 400);
            // å«æ˜Ÿä½ç½®åŠ¨ç”»
            satellite.position.x = 250 * Math.sin(radian);
            satellite.position.y = 100 * Math.cos(radian);
            satellite.position.z = -100 * Math.cos(radian);
            satellite.rotation.x += 0.005;
            satellite.rotation.y += 0.005;
            satellite.rotation.z -= 0.005;
            // æ˜Ÿæ˜ŸåŠ¨ç”»
            stars.rotation.y += 0.0009;
            stars.rotation.z -= 0.0003;
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            // é¡µé¢é‡ç»˜æ—¶è°ƒç”¨è‡ªèº«
            window.requestAnimationFrame(tick);
        }
        tick();
    </script>
</body>

</html>